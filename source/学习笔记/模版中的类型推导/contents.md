# C++ 类型推导

首先我们需要明白一个概念，引用折叠。

## 引用折叠

当我们对一个引用继续引用时，就会发生引用折叠。当然，我们不能主动对一个引用进行引用，但是在模版类型中，会出现引用的引用的情况。  
我们需要制定规则来解决这个问题。  
首先，左右值引用都是一次引用，尽管右值引用有两个`&`符号，但这不代表两层引用，只是为了区分左值引用。  
下面来看一些二层引用的引用折叠规则：    

* X& & -> X&
* X& && -> X&
* X&& & -> X&
* X&& && -> X&&  
  总而言之，就是右值引用的右值引用会折叠为右值引用，其他情况都会折叠为左值引用。X为普通类型或者const都是成立的。

## 类型推导例子

对下面每个调用，确定T和val的类型。

```cpp
template <typename T> void g(T&& val);
int i = 0; const int ci = i;
g(i); // 情况1
g(ci); // 情况2
g(i * ci); // 情况3
```

在推导之前我们还需要明白一个函数调用匹配的原则。

### 函数调用匹配

匹配首先是函数名匹配，然后是参数个数匹配，最后是参数类型匹配或者可以转换亦或者可以接收。  
关于形参可以接收的实参类型，const对象对const对象，非const对非const。  
引用折叠最后得到要么左值引用，要么右值引用，再组合const，那么实际上就是三种引用类型。     

```cpp
void g(int& val); // int类型传引用，会改变实参
void g(const int& val); // const的int类型传引用，不会改变实参
void g(int&& val); // int类型传右值引用，无法修改实参
```

我们回到类型推导的例子。  
首先i是左值非const，那么g(i)最佳匹配是g(int& val), val类型为int&。再看引用折叠T && -> int&，T类型为int&。  
ci是左值const，那么g(ci)最佳匹配是g(const int& val), val类型为const int&。再看引用折叠T && -> const int&，T类型为const int&。  
i * ci是右值，那么g(i * ci)最佳匹配是g(int&& val), val类型为int&&。再看T && -> int&&，T类型为int(理想状态下不需要引用折叠)。  
